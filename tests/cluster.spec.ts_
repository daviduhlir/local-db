import { expect } from 'chai'
import { LocalDB } from '../dist'
import * as path from 'path'
import * as fs from 'fs'
import * as cluster from 'cluster'

const TEST_DB_PATH = path.join(__dirname, '.test-db-cluster')
const WORKER_PATH = path.join(__dirname, 'cluster-worker.ts')

describe('Cluster Tests', () => {
  before(() => {
    // Setup cluster to use our worker file with ts-node
    if (!cluster.isWorker) {
      cluster.setupMaster({
        exec: WORKER_PATH,
        execArgv: ['-r', 'ts-node/register'],
      })
    }
  })

  beforeEach(() => {
    // Clean up test database only in master
    if (!cluster.isWorker && fs.existsSync(TEST_DB_PATH)) {
      fs.rmSync(TEST_DB_PATH, { recursive: true, force: true })
    }
  })

  afterEach(() => {
    // Clean up test database only in master
    if (!cluster.isWorker && fs.existsSync(TEST_DB_PATH)) {
      fs.rmSync(TEST_DB_PATH, { recursive: true, force: true })
    }
  })

  it('should handle concurrent inserts from multiple workers', async function() {
    this.timeout(20000)

    if (!cluster.isWorker) {
      const numWorkers = 3
      const insertsPerWorker = 5
      const workers: cluster.Worker[] = []
      const insertedIds: string[] = []

      // Create workers
      for (let i = 0; i < numWorkers; i++) {
        const worker = cluster.fork()
        workers.push(worker)
      }

      // Wait for all workers to be ready
      await Promise.all(
        workers.map(
          worker =>
            new Promise<void>(resolve => {
              const handler = (msg: any) => {
                if (msg.type === 'ready') {
                  worker.off('message', handler)
                  resolve()
                }
              }
              worker.on('message', handler)
            })
        )
      )

      // Give workers time to stabilize
      await new Promise(resolve => setTimeout(resolve, 100))

      // Send insert commands to all workers
      const insertPromises = workers.map((worker, workerIndex) => {
        return new Promise<void>((resolve, reject) => {
          let insertCount = 0
          let errorOccurred = false

          const handler = (msg: any) => {
            if (errorOccurred) return

            if (msg.type === 'inserted') {
              insertedIds.push(msg.id)
              insertCount++

              if (insertCount < insertsPerWorker) {
                // Send next insert
                worker.send({
                  type: 'insert',
                  data: {
                    counter: insertCount,
                    workerId: workerIndex,
                    message: `Worker ${workerIndex} insert ${insertCount}`,
                  },
                })
              } else {
                worker.off('message', handler)
                resolve()
              }
            } else if (msg.type === 'error') {
              errorOccurred = true
              worker.off('message', handler)
              reject(new Error(msg.error))
            }
          }

          worker.on('message', handler)

          // Send first insert
          worker.send({
            type: 'insert',
            data: {
              counter: 0,
              workerId: workerIndex,
              message: `Worker ${workerIndex} insert 0`,
            },
          })
        })
      })

      await Promise.all(insertPromises)

      // Cleanup workers
      await Promise.all(
        workers.map(
          worker =>
            new Promise<void>(resolve => {
              worker.send({ type: 'done' })
              worker.once('exit', () => resolve())
            })
        )
      )

      // Give time for cleanup
      await new Promise(resolve => setTimeout(resolve, 200))

      // Verify all inserts were successful
      expect(insertedIds).to.have.lengthOf(numWorkers * insertsPerWorker)

      // Verify all IDs are unique
      const uniqueIds = new Set(insertedIds)
      expect(uniqueIds.size).to.equal(insertedIds.length)

      // Verify data in DB
      const db = new LocalDB(TEST_DB_PATH, {
        indexes: {
          counter: { path: 'counter' },
          workerId: { path: 'workerId' },
        },
      })
      await db.open()

      // Check each worker's data
      for (let i = 0; i < numWorkers; i++) {
        const results = await db.getIndex('workerId').get(i)
        expect(results).to.have.lengthOf(insertsPerWorker)
      }

      await db.close()
    }
  })

  it('should handle concurrent queries from multiple workers', async function() {
    this.timeout(20000)

    if (!cluster.isWorker) {
      // First, create some documents
      const db = new LocalDB(TEST_DB_PATH, {
        indexes: {
          counter: { path: 'counter' },
          workerId: { path: 'workerId' },
        },
      })
      await db.open()

      for (let i = 0; i < 10; i++) {
        await db.insert({
          counter: i,
          workerId: 0,
          message: 'test data',
        })
      }

      await db.close()

      // Give time for DB to close
      await new Promise(resolve => setTimeout(resolve, 100))

      // Now create workers to query
      const numWorkers = 3
      const workers: cluster.Worker[] = []

      for (let i = 0; i < numWorkers; i++) {
        const worker = cluster.fork()
        workers.push(worker)
      }

      // Wait for all workers to be ready
      await Promise.all(
        workers.map(
          worker =>
            new Promise<void>(resolve => {
              const handler = (msg: any) => {
                if (msg.type === 'ready') {
                  worker.off('message', handler)
                  resolve()
                }
              }
              worker.on('message', handler)
            })
        )
      )

      // Give workers time to stabilize
      await new Promise(resolve => setTimeout(resolve, 100))

      // Each worker queries the data
      const queryPromises = workers.map(worker => {
        return new Promise<number>((resolve, reject) => {
          const handler = (msg: any) => {
            if (msg.type === 'query-result') {
              worker.off('message', handler)
              resolve(msg.count)
            } else if (msg.type === 'error') {
              worker.off('message', handler)
              reject(new Error(msg.error))
            }
          }

          worker.on('message', handler)

          worker.send({
            type: 'query',
            data: { workerId: 0 },
          })
        })
      })

      const results = await Promise.all(queryPromises)

      // All workers should see all 10 documents
      results.forEach(count => {
        expect(count).to.equal(10)
      })

      // Cleanup workers
      await Promise.all(
        workers.map(
          worker =>
            new Promise<void>(resolve => {
              worker.send({ type: 'done' })
              worker.once('exit', () => resolve())
            })
        )
      )

      // Give time for cleanup
      await new Promise(resolve => setTimeout(resolve, 200))
    }
  })
})